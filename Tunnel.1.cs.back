using MinecraftTunnel.Protocol;
using MinecraftTunnel.Protocol.ClientBound;
using MinecraftTunnel.Protocol.ServerBound;
using System;
using System.Net;
using System.Net.Sockets;
using System.Text.Json;

public class Tunnel
{
    private readonly Socket listenSocket;
    private Socket Client;
    private Socket Server;
    public Tunnel(string IP,int Port)
    {
        listenSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
        //本机预使用的IP和端口
        IPEndPoint serverIP = new IPEndPoint(IPAddress.Any, Port);
        //绑定服务端设置的IP
        listenSocket.Bind(serverIP);
        //设置监听个数
        listenSocket.Listen(100);


        Server = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
        Server.Connect(new IPEndPoint(IPAddress.Parse(IP), Port));
    }

    public void Start()
    {
        while (true)
        {
            Client = listenSocket.Accept();
            while (Client.Connected)
            {

                byte[] buffer = new byte[1024 * 1024];
                int len = Client.Receive(buffer);
                if (len <= 0)
                    break;
                Block receive = new Block(buffer);
                int PacketSize = receive.readVarInt();
                int PacketId = receive.readVarInt();
                if (PacketId == 0)
                {
                    Handshake handshake = new Handshake();
                    handshake.ProtocolVersion = receive.readVarInt();
                    int ServerAddressLength = receive.readVarInt();
                    handshake.ServerAddress = receive.readString(ServerAddressLength);
                    handshake.ServerPort = receive.readShort();

                    int State = receive.readVarInt();

                    handshake.NextState = (NextState)State;


                    int i1 = handshake.ServerAddress.IndexOf("\000");
                    if (i1 == -1)
                        i1 = ServerAddressLength;

                    /*
                    Block block = new Block();
                    block.WriteInt(0);
                    block.WriteInt(handshake.ProtocolVersion);
                    block.WriteString("mc.hypixel.net", true);
                    block.WriteUShort(handshake.ServerPort);
                    block.WriteInt((int)handshake.NextState);

                   
                    int i = block.step;
                    while (true)
                    {
                        byte b = (byte)(i & 0x7F);
                        i >>= 7;
                        if (i != 0)
                            b = (byte)(b | 0x80);

                        byte[] arrayOfByte = new byte[1];
                        arrayOfByte[0] = b;
                        Server.Send(arrayOfByte);
                        if (i == 0)
                        {
                            Server.Send(block.GetBytes());
                            break;
                        }
                    }
                     */

                    if (handshake.NextState == NextState.status)
                    {


                        Response response = new Response();
                        JsonSerializer.Serialize(response);


                        using (Block temp = new Block())
                        {
                            temp.WriteInt(0);
                            temp.WriteString("{\"version\":{\"name\":\"1.8.7\",\"protocol\":47},\"players\":{\"max\":100,\"online\":5,\"sample\":[{\"name\":\"thinkofdeath\",\"id\":\"4566e69f-c907-48ee-8d71-d7ba5aa00d20\"}]},\"description\":{\"text\":\"Hello world\"},\"favicon\":\"data:image/png;base64,<data>\"}", true);
                            byte[] b = temp.GetBytes();
                            using (Block packet = new Block())
                            {
                                packet.WriteInt(b.Length);
                                packet.stream.Write(b);

                                Client.Send(packet.GetBytes());
                            }
                            Console.Out.WriteLine("New player.");
                        }

                     


                        break;
                    }
                }
            }
        }
    }

}